\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs} % for "\midrule" macro
\usepackage{lipsum} % for filler text
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{array}
\usepackage{lplfitch}
\usepackage{hyperref}
\usepackage{caption}
%note this LaTeX package was not written by me and taken from stackexchange forums to be used to write java code formatted
%link to original page https://stackoverflow.com/questions/3175105/inserting-code-in-this-latex-document-with-indentation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%note this LaTeX package was not written by me and taken from stackexchange forums to be used to write z3 code formatted
%link to original page https://github.com/mewmew/latex/blob/master/z3/lang.sty
\lstdefinelanguage{z3}{
	sensitive=true,
	alsoletter={\-},
	% comments.
	%    ; line comment
	comment=[l]{;},
	% Z3 keywords.
	keywords=[1]{
apply, assert, assert-soft, check-sat, check-sat-using, compute-interpolant,
declare-const, declare-datatypes, declare-fun, declare-map, declare-rel,
declare-sort, declare-tactic, define-sort, display, echo, eval, exit,
fixedpoint-pop, fixedpoint-push, get-assertions, get-assignment, get-info, get-
interpolant, get-model, get-option, get-proof, get-unsat-core, get-user-tactics,
get-value, help, help-tactic, labels, maximize, minimize, pop, push, query,
reset, rule, set-info, set-logic, set-option, simplify
	},
	% Z3 built-ins
	morekeywords=[2]{
check-sat-using, declare-var, declare-rel, rule, query, set-predicate-
representation, maximize, minimize, assert-soft, assert-weighted, compute-
interpolant
	},
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\moveToRight[1]{\hspace*{0em plus 1fill}\makebox{(#1)}}
\newcommand*\fixindent{ \hspace{1pt}\\}
%this command below is not my work was used for quality of life
%link to original post 
%https://tex.stackexchange.com/questions/330588/how-to-produce-given-number-of-quad-in-math
\newcommand{\myquad}[1][1]{\hspace*{#1em}\ignorespaces}
\title{Assignment Two}
\author{Abanob Tawfik\\z5075490}
\date{March 2019}

\begin{document}
\maketitle
\section{Problem 1}
Use Natural Deduction to show the following: \moveToRight{10 marks}\\
\begin{center}
$\vdash P(a)\to \forall x(P(x) \lor \neg(x = a))$    
\end{center}

        Solution:\\
        \fitchprf{}{
            \subproof{\pline[1.]{$\neg (P(a)\to \forall x(P(x) \lor \neg(x = a))$}}{
                \subproof{\pline[2.]{$P(a)$}}{
                    \subproof{\pline[3.]{$\neg(P(b) \lor \neg (b = a))$}}{
                        \subproof{\pline[4.]{$\neg P(b)$}}{
                            \subproof{\pline[5.]{$b = a$}}{
                                \pline[6.]{$\neg P(a)$} \eqe{4}{5}\\
                                \pline[7.]{$\bot$} \lfalsei{2}{6}
                            }
                            \pline[8.]{$\neg(b = a)$} \lnoti{5--7}\\
                            \pline[9.]{$P(b) \lor  \neg(b = a)$}[$\lor$ Intro-2: 8]\\
                            \pline[10.]{$\bot$}\lfalsei{3}{9}
                        }
                        \pline[11.]{$\neg\neg P(b)$} \lnoti{4--10}\\
                        \pline[12.]{$P(b)$}[Double Negation Elim: 11]\\
                        \pline[13.]{$P(b) \lor \neg(b = a)$}[$\lor$ Intro-1: 12]\\
                        \pline[14.]{$\bot$}\lfalsei{3}{13}
                    }
                    \pline[15.]{$\neg\neg(P(b) \lor \neg(b = a))$} \lnoti{3--14}\\
                    \pline[16.]{$(P(b) \lor \neg(b = a))$}[Double Negation Elim: 15]\\
                    \pline[17.]{$\forall x(P(x) \lor \neg(x = a))$} \lalli{16}
                }
                \pline[18.]{$P(a) \to\forall x(P(x) \lor \neg(x = a))$} \lifi{2--17}\\
                \pline[19.]{$\bot$}\lfalsei{1}{18}
            }
            \pline[20.]{$P(a) \to\forall x(P(x) \lor \neg(x = a))$} [IP: 1-19]
        }\\\\
        Since i had used a derived rule "Double Negation Elim" i will also provide a proof for this rule on the next page. 
        
\newpage
\fixindent{}
Proof for "Double Negation Elim"\\
\begin{center}
$\neg\neg \psi(a)\vdash \psi(a))$    
\end{center}
Solution:\\
 \fitchprf{\pline[1.]{$\neg\neg \psi(a)$}}{
            \subproof{\pline[2.]{$\neg \psi(a)$}}{
                \pline[3.]{$\bot$}\lfalsei{1}{2}
            }
            \pline[4.]{\psi(a)}[IP: 1-3]
        }\\\\
Explanation of the proof:\\
\fixindent{}
This proof has no premises, so in order to perform a proof of such we need an indirect proof which can also be seen as proof by contradiction. First we assume the opposite of what we are trying to prove, in this case the negation of our consequence:
\fixindent{}
\hspace*{150pt}$\neg(P(a) \to \forall x(P(x) \lor \neg(x = a)))$\\\fixindent{}
Next we want to try to arrive to the contradiction somewhere down the proof. We use modus ponen by assuming $P(a)$ and trying to reach the conclusion in the subproof $\forall x(P(x) \lor \neg(x = a))$ allowing us to introduce implication and arrive to a direct contradiction:
\fixindent{}
\hspace*{150pt}$P(a) \to \forall x(P(x) \lor \neg(x = a))$
\fixindent{}\fixindent{}
We want to make the assumption of the negation of the conclusion we are trying to reach using variable b, as when b is no longer a free variable in x, in other words we are no longer working under the assumption $P(b)$ and b is arbitrary we can perform a $\forall$ introduction.\\
\fixindent{}
Since the consequence $\forall x(P(x) \lor \neg(x = a))$ contains $\lor$, we only need one side of the predicate to perform a $\lor$ introduction. To do this properly and allow use of the $\forall$ introduction we need to make b an arbitrary variable. We make the assumption $\neg P(b)$ and under that we make another assumption b = a. By doing this we can perform an equals elimination (substitution) to arrive at $\neg P(a)$ which is a direct contradiction to our first assumption $P(a)$. This gives us $\bot$ which implies $\neg (b = a)$ and this can also be done to imply $P(b)$ similarly.\\
\fixindent{}
By having the above under the assumption $\neg(P(b) \lor \neg(b = a))$ we can perform a $\lor$ introduction on $P(b)$ above to introduce $\neg(b = a)$ arriving at P(b) $\lor$ $\neg(b = a)$ which is again another contradiction. Since this subproof concludes to $\bot$ we can assume the negation of our initial assumption for the subproof which is $P(b) \lor \neg(b = a)$. Because b is an arbitrary variable, $\neg P(b)$ was discharged, we can simply perform a $\forall$ introduction and arrive to the conclusion:\\
\hspace*{150pt}$P(a) \to \forall x(P(x) \lor \neg(x = a))$
\fixindent{}
\fixindent{}
This is a direct contradiction to our initial assumption $\neg(P(a) \to \forall x(P(x) \lor \neg(x = a)))$, giving us $\neg\neg(P(a) \to \forall x(P(x) \lor \neg(x = a)))$. Performing one more double negation elimination (proven in the second natural deduction proof) gives us the following conclusion by indirect proof:
\fixindent{}
\fixindent{}
\hspace*{150pt}$\vdash P(a)\to \forall x(P(x) \lor \neg(x = a))$
\newpage
\begin{flushleft}
The following images below were taken from the following natural deduction verification tool,  \href{https://proofs.openlogicproject.org/}{https://proofs.openlogicproject.org/}, which was used to validate the following natural deduction that was performed in the problem and the proof of the derived rule for double negation elimination. Note that rule DNE was used  on the image, this was a derived rule that was proven and verified in the next image.\\
\end{flushleft}
\begin{centering}\hspace*{1pt}\includegraphics[width=400px, height = 400px]{p2.png}\captionof{figure}{Verification tool returning that my proof is correct for main proof}\end{centering}
\newpage
\begin{flushleft}
Below is the image showing the proof for the derived rule DNE which states that $\neg\neg P = P$.\\
\begin{centering}\hspace*{1pt}\\\includegraphics[width=300px, height = 300px]{p1.png}\captionof{figure}{Verification tool returning that my proof of the derived rule DNE is correct}\end{centering}
\end{flushleft}
\newpage
\section{Problem 2}
\textbf{Please see the appendix for the full java code that can be copied and pasted and run to display the model. the code that was used inside this question is a bit too split up and cannot be easily copied and pasted however do give a good view of what i am trying to say.}\\\\
Recall from Assignment 1 the problem of assigning channels to wifi networks to avoid interference. The
task in this assignment is to set up a logical framework that can handle the same problem in a more
general setting: i.e. with more than two channels and a wider variety of proximity topologies. As before we have some standard requirements:
    \begin{enumerate}[I]
        \item A network uses one, and only one channel.
        \item Networks within close proximity cannot both use the same channel.
        \item “Close proximity” is an anti-reflexive, symmetric relation.
    \end{enumerate}
\begin{enumerate}[(a)]
        \item Carefully define a specification language (that is, a vocabulary or set of propositional variables) necessary to formally specify the requirements laid out above. You may:
        \begin{itemize}
            \item consider the problem in propositional logic or predicate logic;
            \item fix the number of channels and/or networks (e.g. assume there are three channels and four networks).
        \end{itemize}
        \textbf{However}, you will be assessed on how extensible your definitions are – in other words, how easy it is to extend the specification language to cover more general settings (e.g. more channels and/or more networks). \moveToRight{4 marks}\\\\
        Solution: \\
        For this problem we will be defining a specification language in the form of a vocabulary to satisfy the above requirements. To define a vocabulary we need to first define our domain of discourse and our set of: 
        \begin{itemize}
            \item Predicate symbols 
            \item Function symbols
            \item Constant symbols
        \end{itemize}
        Our two objects inside our domain of discourse are channels and networks which can be viewed as the following:\\
        Channel:
        \begin{itemize}
            \item Integer id (represents the channel state e.g, 0 = low, 1 = medium, 2 = high)  
        \end{itemize}
        Network:
        \begin{itemize}
            \item String name
            \item Channel connected
            \item List$<$String$>$ close\_proximity\_networks (String was used since it can be the identifier of Network assuming unique naming)
        \end{itemize}
        Using these definitions we can construct the following predicates for our vocabulary:
        
        Network(name, channel,close\_proximity\_networks) which will be used to return true if the tuple values match the entry for the network.\fixindent{}
        
        Channel(id) which will be our unary predicate that returns true if the channel with the corresponding id exists, otherwise false.\fixindent{}
        
        is\_close\_proximity(network1, network2) which resolves to true if the two networks are in close proximity (the networks are in each others close proximity list) or false if otherwise.\fixindent{}
        
        valid\_channel\_configuration(network1, network2) which will resolves to true if the networks have no interference (network 1's channel is different to network 2's channel).\\\fixindent{}
        is\_connected(network, channel) which will resolve to true if the network is connected to that channel (we can have the channel connected to be -1 before assignment to indicate it is yet to be assigned to a channel.
        
        \fixindent{} Some other unary predicates to restrict our domain of discourse would include:\fixindent{}is\_integer(value) which will be used to make sure valid entries for channel ids.\\is\_String(value) which will be used to make sure valid entries for Network names.\fixindent{}
        
        For this problem it is mostly relational and predicate based so there are no function symbols and constant symbols and these can be considered an empty set. Our vocabulary V can be seen as:\\
        V = \{Network, Channel, is\_close\_proximity, valid\_channel\_configuration, is\_connected, is\_integer, is\_String\}\\\fixindent{}
        With this vocabulary we are able to setup a solution to any configuration (if there is one) with n networks and m channels by making sure each network is connected, and making sure that each network in close proximity are on different channels.    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        
        \item In your specification language, and subject to the assumptions you have made, define the requirements with logical formulas:
        
        Please note for this question i will use the variable X to represent all networks and x to represent individual networks. similarly i will be using the variable Y to represent all channels and y to represent individual channels. A quick explanation of the predicate formulas will also be provided in code and in propositional logic aswell.!
        \begin{enumerate}[(i)]
            \item A network uses one, and only one channel. \moveToRight{2 marks}\\\\
            Solution: \\
            $\psi_1 = \exists x_1 \in X, \exists y_1 \in Y (P(x_1,y_1) \land \forall y_2 \in Y (is\_connected(x_1, y_2)) \to y_2 = y_1)$\\\\
            Essentially what we are saying is that a network is connected to a channel, and  if any other channel satisfies that connection, than the channels are equivalent.\\
            The following predicate can be seen in propositional logic as the following:\\ Assuming there are n channels and $A_i$ represents the proposition that network A is connected to channel i, then we can construct the proposition that a network uses one and only channel in the following:\\
            $\sigma = A_1 \lor A_2 \lor A_3 \lor A_4 \lor ... \lor A_n$ (network is connected to any channel)\\ 
            $\phi_1 = \neg(A_1 \land A_2) \land \neg(A_1 \land A_3) \land ... \land \neg(A_1 \land A_n)$ (no multiple connections on channel 1 but this needs to be done for all channels) 
            $\phi = \phi_1 \land \phi_2 \land \phi_3 \land ... \land \phi_{n-1}$\\
            so our proposition is $\sigma \land \phi$\\\\
            Essentially $\phi$ says that for all possible combinations of connections with collisions we make sure that none of these are true, for example if there were three channels we would say 
            $\phi_1 = \neg(A_1 \land A_2) \land \neg(A_1 \land A_3)$\\
            $\phi_2 = \neg(A_2 \land A_3)$ \moveToRight{note $A_2 \land A_1$ is captured in $\phi_1$}\\
            $\phi = \phi_1 \land \phi_2$\\
            \hspace*{5pt} $= \neg(A_1 \land A_2) \land \neg(A_1 \land A_3) \land \neg(A_2 \land A_3)$\\
            $\sigma$ says that we are connected to any network, so we must be connected to one network, for example if there were three channels we would say\\
            $\sigma = A_1 \lor A_2 \lor A_3$\\ Putting these together we have the predicate function for 3 channels (note this can be extended to any amount of channels\\ $is\_connected(network, channel) = (channel_1 \lor channel_2 \lor channel_3) \land \neg(channel_1 \land channel_2) \land \neg(channel_1 \land channel_3) \land \neg(channel_2 \land channel_3)$\\\\
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \item Networks within close proximity cannot both use the same channel. \moveToRight{2 marks}\\\\
            Solution: \\
            $\psi_2 = \forall x_1 \in X(\forall x_2 \in X(is\_close\_proximity(x1, x2) \to valid\_configuration(x1, x2)))$\\\\
            We are saying that we will check each network with every other network and for all combinations (nested for loop style) if two networks are in close proximity that implies they are in a valid configuration (using different channels). By using the same amount of channels as the question above and this time using channel A and channel B in close proximity we can set up the propositional formula, that if the channels A and B are in close proximity they are on different channels in the following way:\\
            $\phi_1 = is\_close\_proximity(A, B)$\\
            let $\phi_2$ be the propositional statement that close proximity networks don't use the same channel. For n amount of networks this can be represented as:\\
            $\phi_2 = \neg(A_1 \land B_1) \land \neg(A_2 \land B_2) \land \neg(A_3 \land B_3) \land ... \land \neg(A_n \land b_n)$\\
            so our requirement $\psi_2$ becomes the following:\\
            $\psi_2 = \phi_1 \to \phi_2$ or in expanded form\\
            $\psi_2 = (is\_close\_proximity(A,B)) \to (\neg(A_1 \land B_1) \land \neg(A_2 \land B_2) \land \neg(A_3 \land B_3) \land ... \land \neg(A_n \land b_n))$\\
            Note is\_close\_proximity(A, B) is simply a predicate which will check if the two networks are close. This predicate formula can also be displayed in code in the following way.\\
            
            \newpage
            Class for channel
            \begin{lstlisting}
public class Channel{

    public int id;
    
    public Channel(int ID){
        this.id = ID;
    }
    
    public int get_Id(){
        return this.id;
    }
}
            \end{lstlisting}
            
            class for Network
            \begin{lstlisting}
import java.util.*;

public class Network{

    public String name;
    public Channel connected;
    public ArrayList<String> close_proximity_networks;
    
    public Network(String name, Channel connected, ArrayList<String> close_proximity_networks){
        this.name = name;
        this.connected = connected;
        this.close_proximity_networks = close_proximity_networks;
    }
    
    public String get_name(){
        return this.name;
    }
    
    public Channel get_channel(){
        return this.connected;
    }
    
    public ArrayList<String> get_close_proximity_networks(){
        return this.close_proximity_networks;
    }
}
            \end{lstlisting}
            
            \newpage
            General solution for this problem and the predicates in code!
            \begin{lstlisting}
import java.util.*;

public class Predicates{

    public ArrayList<Network> all_networks;
    public ArrayList<Channel> all_channels;
    
    public boolean is_close_proximity(Network n1, Network n2){
        //if the network name is apart of the other networks close proximity network list then return true
        if(n1.get_close_proximity_networks().contains(n2.get_name())){
            return true;
        }
        //return false otherwise
        return false;
    }
    
    public boolean valid_configuration(Network n1, Network n2){
        //if the two networks are in close proximity then we check the channels are different to return true
        if(is_close_proximity(n1, n2){
            //both networks use different channels
            return n1.get_channel().get_id() != n2.get_channel().get_id();
        }
        //if the channels are not in close proximity then it is valid eitherway
        return true;
    }
    
    //Now we can construct our final predicate
    public boolean all_configurations_valid(){
        //we want to check all possible configurations
        for(Network n1 : all_networks){
            for(Network n2 : all_networks){
                //anti-reflexive property as this will lead to invalid configuration
                if(n1 == n2){
                    continue;
                }
                //if ANY configuration is invalid we return false as the setup is invalid
                if(!valid_configuration(n1, n2){
                    return false;
                }
            }
        }
        //return true if it does not exit the loop with return false
        return true;
    }
}
                \end{lstlisting}\\
            Note the following predicates for the vocabulary have been defined in the java code above.\\\\
            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
            \item “Close proximity” is an anti-reflexive, symmetric relation. \moveToRight{2 marks}\\\\
            Solution: \\
            $\psi_3 = \forall x1 \in X(\neg is\_close\_proximity(x1,x1))$\\
            $\psi_4 = \forall x1 \in X(\forall x2 \in X(is\_close\_proximity(x1,x2) \to is\_close\_proximity(x2,x1))$\\\\
            $\psi_3$ is the logical formula which states for all networks inside our network domain, they cannot be in close proximity with themselves which is an anti-reflexive relation.\\\\
            $\psi_4$ is the logical formula which states for all networks if network A is in close proximity to network B, then that also implies network B is in close proximity with network A which a symmetric relation.\\\\
            "Close proximity" must be an anti-reflexive and symmetric relation in order for valid configurations. This is because if a Network can be in close proximity with itself that means the valid\_configuration would return false since it will show up as both networks using the same channel even though its the same network. "Close proximity" must also be a symmetric relation, since if A is in close proximity with B, that means B must be in close proximity with A. The above formulas slightly modify the code we have written above the following\\
            re-defining the code to allow close\_proximity to be an anti-reflexive and symmetric. 
            \begin{lstlisting}
public boolean is_close_proximity(Network n1, Network n2){
    //anti-reflexive property by not letting n1 = n2 be true
    //i.e. if the two networks are the same return false!
    if(n1 == n2){
        return false;
    }
    //adding the symmetric relation by making n1 close proximity to n2
    if(n2.get_close_proximity_networks().contains(n1.get_name())){
        return true;
    }
    //if the network name is apart of the other networks close proximity network list then return true
    if(n1.get_close_proximity_networks().contains(n2.get_name())){
        return true;
    }
    //return false otherwise
    return false;
}
            
            
            
            
            
            
            
            
//this allows use to now modify all_valid configuration to the following
//since we now have anti-reflexive inside our close proximity rather than in the predicate all_configurations_valid we can just simply call valid_configuration(n1,n2)
public boolean all_configurations_valid(){
        //we want to check all possible configurations
        for(Network n1 : all_networks){
            for(Network n2 : all_networks){
                //if ANY configuration is invalid we return false as the setup is invalid
                if(!valid_configuration(n1, n2){
                    return false;
                }
            }
        }
        //return true if it does not exit the loop with return false
        return true;
}
            \end{lstlisting}
             Note that since we have "close proximity" as a symmetric relation, that means if network A is inside of network B's close proximity list, that also means that network B is also inside of network A's close proximity list, this can be shown in code with the following.
        
        \begin{lstlisting}
//suppose this is the method for making two networks within close proximity
public void make_close_proximity(Network A, Network B){
    //this shows the symmetry since A is close proximity to B
    //also means B is close proximity to A
    //since we make them BOTH close proximity to each other.
    A.get_close_proximity_networks.add(B.get_name());
    B.get_close_proximity_networks().add(A.get_name());
}
        \end{lstlisting}.
        \end{enumerate}
       
        \newpage
        \begin{flushleft}
            Consider the following set-up: we have exactly three channels: hi, med, lo; and (at least) four networks Alpha, Bravo, Charlie, Delta with close proximity as defined in the following diagram:
        \end{flushleft}

        \begin{centering}\hspace*{1pt}\\\includegraphics[width=100px, height = 100px]{network2.png}\captionof{figure}{Network configuration between all four networks and three channels}\end{centering}
        We now want to refine our specification (i.e. add requirements) so that any model which satisfies all the requirements will necessarily have the structure detailed here.
        
        \item  Extending your specification language if necessary, provide a set of requirements which, together with your answer to (b), ensures any satisfying model has the structure detailed here. \moveToRight{10 marks}\\\\
        Solution: \\
        Since in part (b) we gave requirements for a more general solution which will solve for any configuration (if there is a solution) we simply just have to add requirements so that all models have the structure shown in Figure 3. The following extra requirements can be added to achieve this:
        \begin{enumerate}[(1)]
            \item we have 4 networks and 3 channels
            \item two UNIQUE networks are in "close proximity" to every other network
            \item the other two networks are ONLY in close proximity to the networks in (2)
        \end{enumerate}
        By saying that the set of all networks is X and the set of all channels is Y
        these requirements can be shown in predicate formulas in the following:
                \begin{enumerate}[(1)]
            \item $\psi_5 = (|X| = 4) \land (|Y| = 3)$\\
            This essentially says that the size of our network set is 4 and the size of our channel set is 3
            \item $\psi_6 = (x1,x2 \exists X(\forall n1 \in X (is\_close\_proximity(x1, n1) \land (is\_close\_proximity(x2,n1)))  \land \\\neg(x1 = x2)$\\
            This essentially says that there exists two networks x1 and x2 in the set of networks which is in close proximity to ALL other networks and those two networks are not the same network. 
            \item $\psi_7 = (x1,x2 \exists X(\forall n1 \in X (is\_close\_proximity(x1, n1) \land (is\_close\_proximity(x2,n1)))  \land \\\neg(x1 = x2) \land \\  (u1, u2 \exists X(is\_close\_proximity(u1, x1) \land is\_close\_proximity(u1, x2) \land \\ is\_close\_proximity(u2, x1) \land is\_close\_proximity(u2, x2) \land \\\neg is\_close\_proximity(u1, u2) \land \neg(u1 = u2) \land \neg (u1 = x1) \land \\\neg(u1 = x2) \land \neg (u2 = x1) \land \neg (u2 = x2))$\\
            This seems like a much more complicated predicate formula, however this is because we needed to write out $\psi_6$ to reference the networks x1 and x2, essentially it states that two networks, x1 and x2, are in close proximity to all other networks and that there are two distinct networks u1 and u2 that are in close proximity to those networks and not in close proximity to each other and they are not the same network.
        \end{enumerate}
        \\We will name our following predicates $\psi_5$ $\psi_6$ $\psi_7$ as correct\_sizes, two\_connected\_to\_all and two\_unique\_connected respectively
        These new requirements can also be added to the previous predicates $\psi_{1-4}$ to give us our final requirement $\psi$ as:\\
        $\psi = \psi_1 \land \psi_2 \land \psi_3 \land \psi_4 \land \psi_5 \land \psi_6 \land \psi_7$\\
        This can also be shown in the code above in part (b) along with the following additions below to introduce our new requirements.
        \begin{lstlisting}
//we will also be adding new class variables
public Network connected_to_all1 = null;
public Network connected_to_all2 = null;
public Network uniq1 = null;
public Network uniq2 = null;
public boolean correct_sizes(){
    return (all_networks.size() == 4 && all_channels.size() == 3);
}
//our predicate to make sure we have only two networks which are in close proximity to all other networks
public boolean two_connected_to_all(){
    //this flag will be used to be a check if the network is
    //in close proximity to all other networks
    //if a network is not in close proximity to any network we want to go to the next
    //network as this one is not connected to ALL networks. we reset the flag at each iteration
    //if the flag is false.
    boolean flag = true;
    //count how many networks are connected to ALL networks
    int count = 0;
    //scan through all combinations of the networks
    for(Network n1 : all_networks){
        for(Network n2 : all_networks){
            //if n1 is not in close proximity to all other networks we want to set flag as false
            //and go to the next network
            if(!is_close_proximity(n1, n2) && n1 != n2){
                flag = false;
                break;
            }
        }
        //if the flag is false that means we dont want to increase the counter or update
        //our class vairables
        if(flag == false){
            flag = true;
            continue;
        }
        //otherwise we want to set the class variables in order
        if(connected_to_all2 == null && connected_to_all1 != null){
            connected_to_all2 = n1;
        }

        if(connected_to_all1 == null){
            connected_to_all1 = n1;
        }
        //and increment the count
        count++;
    }
    //return the statement that the count must be exactly 2
    //and that the two networks connected to all the other networks
    //are not the same network
    return (count == 2) && (connected_to_all1 != connected_to_all2);
}

//our predicate to make sure that the other two networks are also connected to the other networks
//that connect to everything and are not connected to any other node
public boolean two_unique_connected(){
    //if we don't have two networks which are connected to all other networks
    if(null == connected_to_all1 || null == connected_to_all2) {
        return false;
    }
    //otherwise we want to isolate the other 2 networks and make sure they are
    //1. connected to the connected_to_all networks AND
    //2. those two networks are not connected to each other
    //3. those two networks are not the same network
    Network n1 = null;
    Network n2 = null;
    //find the two networks which are not the ones connected to the rest of the networks
    for(Network n : all_networks){
        if(n1 != null && (n != connected_to_all1 && n != connected_to_all2) && n2 == null){
            n2 = n;
        }
        if((n != connected_to_all1 || n != connected_to_all2) && n1 == null){
            n1 = n;
        }
    }
    //if those two networks are NOT in close proximity with ONLY the two networks that are connected
    //to the rest, we return false
    if(n1.get_close_proximity_networks().size() != 2 && n2.get_close_proximity_networks().size() != 2){
        return false;
    }
    //if those two networks are in close proximity to each other
    //return false
    if(is_close_proximity(n1, n2)){
        return false;
    }
    //if the network is not in close proximity with the two networks
    //connected to the all networks, return false
    if(!n1.get_close_proximity_networks().contains(connected_to_all2.get_name()) &&
            !n1.get_close_proximity_networks().contains(connected_to_all1.get_name())){
        return false;
    }
    if(!n2.get_close_proximity_networks().contains(connected_to_all2.get_name()) &&
            !n2.get_close_proximity_networks().contains(connected_to_all1.get_name())) {
        return false;
    }
    //otherwise return true since it has passed all checks
    unique1 = n1;
    unique2 = n2;
    return true;
}
    \end{lstlisting}
    With our new predicates which restrict all models to the configuration in Figure 3 we can finally modify all\_configurations\_valid which achieved $\psi$ in the following code
    \begin{lstlisting}
//this allows use to now modify all_valid configuration to the following
//since we now have anti-reflexive inside our close proximity rather than in the predicate all_configurations_valid we can just simply call valid_configuration(n1,n2)
public boolean all_configurations_valid(){
    //we want to check all possible configurations
    for(Network n1 : all_networks){
        for(Network n2 : all_networks){
            //if ANY configuration is invalid we return false as the setup is invalid
            if(!valid_configuration(n1, n2)){
                return false;
            }
        }
    }
    //return true if it does not exit the loop with return false
    return correct_sizes() && two_connected_to_all() && two_unique_connected();
}
        \end{lstlisting}
        from these predicates we can also make the observation that since two networks are connected to every other networks, those networks must run on different channels, and since the other two networks are not connected to each other, they must run on the same channel (this will be proven in (c) and (d). The following is a satisfying model to this problem. 
        \begin{enumerate}
            \item A = channel medium
            \item B = channel High
            \item C = channel medium
            \item D = channel low
        \end{enumerate}
        \newpage
        When this is run with the following test code given the same configuration, we receive the following output
        \begin{lstlisting}
import java.util.*;

public class test {
    public static void main(String args[]) {
        Channel low = new Channel(0);
        Channel medium = new Channel(1);
        Channel high = new Channel(2);

        ArrayList<String> close_proximity_to_a = new ArrayList<String>();
        close_proximity_to_a.add("B");
        close_proximity_to_a.add("D");
        Network A = new Network("A", medium, close_proximity_to_a);

        ArrayList<String> close_proximity_to_b = new ArrayList<String>();
        close_proximity_to_b.add("A");
        close_proximity_to_b.add("C");
        close_proximity_to_b.add("D");
        Network B = new Network("B", high, close_proximity_to_b);

        ArrayList<String> close_proximity_to_c = new ArrayList<String>();
        close_proximity_to_c.add("B");
        close_proximity_to_c.add("D");
        Network C = new Network("C", medium, close_proximity_to_c);

        ArrayList<String> close_proximity_to_d = new ArrayList<String>();
        close_proximity_to_d.add("A");
        close_proximity_to_d.add("B");
        close_proximity_to_d.add("C");
        Network D = new Network("D", low, close_proximity_to_d);

        ArrayList<Channel> channels = new ArrayList<Channel>();
        channels.add(low);
        channels.add(medium);
        channels.add(high);

        ArrayList<Network> networks = new ArrayList<Network>();
        networks.add(A);
        networks.add(B);
        networks.add(C);
        networks.add(D);

        Predicates check = new Predicates(networks, channels);
        System.out.println("Correct size of configuration 4 networks 3 channels- : " + check.correct_sizes());
        System.out.println("Only two networks connected to all other networks: " + check.two_connected_to_all());
        System.out.println("Two networks connected to the ones above but not to each other: " + check.two_unique_connected());
        
        System.out.println("Final valid configuration (main requirements): " + check.all_configurations_valid());
        System.out.println("A connected to : " + A.get_close_proximity_networks());
        System.out.println("B connected to : " + B.get_close_proximity_networks());
        System.out.println("C connected to : " + C.get_close_proximity_networks());
        System.out.println("D connected to : " + D.get_close_proximity_networks());
        System.out.println("The two channels which were connected to all other channels satisfying psi_6 are : "
                + check.connected_to_all1.get_name() + " and "
                + check.connected_to_all2.get_name());
        System.out.println("The two channels which are unique satisfying psi_7 are : " 
                + check.unique1.get_name() + " and " + check.unique2.get_name());
        
    }
}

        \end{lstlisting}
        When the above code is run we get the following output
        \begin{centering}\hspace*{1pt}\\\includegraphics[width=400px, height = 200px]{output3.png}\captionof{figure}{code output with the configuration above with same structure in Figure 3}\end{centering}
        Note this code produces the correct output and can be copied and pasted from the appendix, and tested with different models. I did not use the predicate make\_close\_proximity in my testing as i already implemented close proximity with the symmetric nature of adding both networks to each other's close proximity list.
        \newpage
        \item How would you use a SAT-solver (for First Order Logic) such as Z3 or IDP to show that in any model satisfying your requirements, Alpha and Charlie use the same channel? \moveToRight{5 marks}\\\\
        Solution:\\
        Similar to the lecture example for solving a simpler version of the zebra puzzle, we would load each of our variables in so that each channel will be loaded in as an integer, and we would set these channels to constant values. So high = 2, medium = 1 and low = 0. Then we would load in our Networks as integers which range from 0-2 (indicating their channels). Next we would assert the conditions that our defined close proximity networks cannot have equal values. So in the defined model above, we have the following:\\
        \begin{itemize}
            \item Alpha != Bravo
            \item Alpha != Delta
            \item Bravo != Alpha
            \item Bravo != Charlie
            \item Bravo != Delta
            \item Charlie != Bravo
            \item Charlie != Delta
            \item Delta != Alpha
            \item Delta != Bravo
            \item Delta != Charlie
        \end{itemize}
        all these conditions enforce the close proximity in the given
        \begin{itemize}
            \item Alpha is in close proximity to Bravo and Delta
            \item Bravo is in close proximity to Alpha, Charlie and Delta
            \item Charlie is in close proximity to Bravo and Delta
            \item Delta is in close proximity to Alpha, Bravo and Charlie
        \end{itemize}
        which follows our structure in Figure 3 as we are also using 3 channels low, medium and high. 
        Next we would try to get all models by adding more conditions and exhausting all possibilities to verify that all satisfying models have Alpha and Charlie on the same Network.\\\\ to get all models we would first run it with those conditions in place, then after we check satisfiability and get the model, we will now make it so alpha cannot be channel 0 and repeat till we have exhausted all possible channels giving all possible models. \\\\ This will also what we will be using for the bonus to implement the solution using Z3.
        \newpage
        \textbf{Bonus:} Implement your solution to the previous question in a SAT-solver to show that in any model satisfying the requirements, Alpha and Charlie use the same channel. Either include a link to your solution or provide the code so it can be easily copy-pasted and run. \moveToRight{10* marks}\\\\
        Solution:\\
        \lstinputlisting[language=z3,firstnumber=1]{z3.txt}
        As can be seen in the following output from the SAT solver Z3, all models that solve the configuration in Figure 3 have alpha and charlie using the same channel, because alpha and charlie have the same value, and bravo and delta use different channels to alpha and charlie and each other.
\end{enumerate}

\newpage
\section{Problem 3}
Recall the Fibonacci sequence defined as:
\begin{itemize}
    \item F(0) = 0
    \item F(1) = 1
    \item F(n + 2) = F(n + 1) + F(n) for n $\geq$ 0
\end{itemize}
    \begin{enumerate}[(a)]
        \item Write a program FIB in $\mathcal{L}$ that computes the n-th Fibonacci number (for n $\geq$ 1). That is, if n $\geq$ 1 at the start of execution, then variable r has value F(n) at the end of execution (if Fib terminates). \moveToRight{12 marks}\\\\
        Solution:\\
        We will use the variable r to store our fib(i) and i will eventually be equal to n assuming the program terminates. We will use the variable x to keep the value of f(i - 1). Note counting starts from 0 since we are also considering fib(0) = 0, the 0th Fibonacci number is 0, the first Fibonacci number is 1, the second Fibonacci number is 1, the third Fibonacci number is 2 and so on.
    \begin{lstlisting}[language=Maple,mathescape=true]
//variable that holds the previous value of f(i) -> (f(i - 1)) this is f(0)
x := 0;
//variable that holds f(i)  ->  (note this is (f(1))
r := 1;
//counter for loop
i := 1;
//while the counter is less than our value n
//note on each iteration (loop invariant we have)
//x = fib(i - 1)
//r = fib(i)
while i < n do
    //set f(i) = f(i - 2) + f(i - 1)
    //this is because we are using assignment and we increment i to i + 1
    //old r becomes f(i - 1) and old x becomes fib(i - 2)
    r := r + x;
    //update x to be f(i - 1) for next iteration
    //since r is updated to f(i) we have f(i) - f(i - 2)
    //giving f(i - 1) e.g. 1, 1 , 2 ,3, 5
    //if we have f(i) as 5, then f(i - 1) is 3
    //f(i - 2) is 2
    //and 5 - 2 = 3 which is f(i - 1) correctly updating for next iteration
    x := r - x;
    //increment loop counter
    i := i + 1;
od
    \end{lstlisting}
    Note that fib(n) = fib(n - 1) + fib(n - 2) is also equivalent to fib(n + 2) = fib(n + 1) + fib(n). This is because fib(1) and fib(0) is already defined for us so we don't end up with negative fib numbers and undefined behaviour. We exit the loop with our invariant being r = f(i) and i $\leq$ n. Our exit condition is when i $\geq$ n, that means i = n, giving us r = f(n)\\
    
    \item Prove, using Hoare Logic, that $\vdash$ \{n $\geq$ 1\} Fib \{r = F(n)\} \moveToRight{10 marks}\\\\
    Solution:\\
    For this solution conditions have been compacted in the following:\\ \{init\} = \{n $\geq$ 1\}\\
    \{invariant\} = \{(f(i) = r) $\land$ (f(i - 1) = x) $\land$ (i $\leq$ n) $\land$ (\{init\})\}\\
    \{updateRpre\} = \{(f(i + 1) = r + x) $\land$ (f(i) = r) $\land$ (i $\leq$ n) $\land$ (n $\geq$ 1)\} note f(i) = (r + x) - x\\
    \{updateRpost\} =  \{(f(i + 1) = r) $\land$ (f(i) = r - x) $\land$ (i  $\leq$ n) $\land$ (n $\geq$ 1)\}\\
    \{updateXpost\} =  \{(f(i + 1) = r) $\land$ (f(i) = x) $\land$  (i $\leq$ n) $\land$ (n $\geq$ 1)\}\\    
    Below this proof we will also prove our proof obligations. The invariant is very similair to the one given in the lecture for the power program example. The overall proof is a mix between the lecture example for factorial and power function.\\
    \begin{enumerate}[1. ]
        \item \{init\} \moveToRight{premise}
        \item \{f(0) = 0\} x := 0 \{x = f(0)\} \moveToRight{assignment inference rule}
        \item \{f(1) = 1\} r := 1 \{r = f(1)\} \moveToRight{assignment inference rule}
        \item \{r = f(1)\} i := 1 \{r = f(i)\} \moveToRight{assignment inference rule}
        \item \{f(1) = 1\} r := 1; i := 1 \{r = f(i)\} \moveToRight{sequence inference rule: 3, 4}
        \item \{updateRpre\} r := r + x \{updateRpost\} \moveToRight{assignment inference rule}
        \item \{updateRpost\} x := r - x \{updateXpost\} \moveToRight{assignment inference rule}
        \item \{updateXpost\} i := i + 1 \{invariant\} \moveToRight{assignment inference rule}
        \item \{updateRpre\} r := r + x; x := r - x \{updateXpost\} \moveToRight{sequence inference rule:  6, 7}
        \item \{updateRpre\} r := r + x; x := r - x; i := i + 1 \{invariant\} \moveToRight{sequence inference rule: 9, 8}
        \item (invariant $\land$ (i $<$ n)) $\to$ (updateRpre) \moveToRight{proof obligation, definition of Fibonacci}
        \item \{invariant $\land$ (i $<$ n)\} r := r + x; x := r - x; i := i + 1\{invariant\}\\ \moveToRight{consequence inference rule: 10, 11}
        \item \{invariant $\land$ (i $<$ n)\} while ... od \{invariant $\land$ (r = f(i)) $\land$ (i $\geq$ n)\} \moveToRight{loop inference rule: 12}
        \item \{(0 = f(0)) $\land$ (1 = f(1)) $\land$ (init)\} Fib \{invariant $\land$ (r = f(i)) $\land$ (i $\geq$ n)\} \moveToRight{seq}
        \item (TRUE $\land$ (n $\geq$ 1)) $\to$ (init $\land$ 1 = f(1) $\land$ 0 = f(0)) \moveToRight{proof obligation}
        \item \{TRUE $\land$ (n $\geq$ 1)\} FIB \{invariant $\land$ (r = f(i)) $\land$ (i $\geq$ n)\}\moveToRight{consequence inference rule: 14, 15}
        \item (invariant $\land$ (r = f(i)) $\land$ (i $\geq$ n)) $\to$ r = f(n) \moveToRight{proof obligation} 
        \item \{TRUE $\land$ (n $\geq$ 1)\} Fib \{r = f(n)\} \moveToRight{consequence inference rule: 16, 17}
    \end{enumerate}
    
    \newpage 
    Proof obligations used in the Hoare logic derivation:\\\\
    Note our substitutions are the following:\\
    \{init\} = \{n $\geq$ 1\}\\
    \{invariant\} = \{(f(i) = r) $\land$ (f(i - 1) = x) $\land$ (i $\leq$ n) $\land$ (\{init\})\}\\
    \{updateRpre\} = \{(f(i + 1) = r + x) $\land$ (f(i) = r) $\land$ (i $\leq$ n) $\land$ (n $\geq$ 1)\}\\\\
    \begin{list}
        \item {Proof for Line 11 - (invariant $\land$ (i $<$ n)) $\to$ (updateRpre)} 
            (invariant $\land$ (i $<$ n)) $\to$ ((f(i + 1) = r + x) $\land$ (f(i) = r) $\land$ (i $\leq$ n) $\land$ (n $\geq$ 1))\\
            So our proof becomes:\\
            (f(i) = r) $\land$ (f(i - 1) = x) $\land$ (i $\leq$ n) $\land$ (n $\geq$ 1)) $\to$ ((f(i + 1) = r + x) $\land$ (f(i) = r) $\land$ (i $\leq$ n) $\land$ (n $\geq$ 1))\\
            with the overlap i $<$ n and i $\leq$ n we can simplify that to i $<$ n because (i $<$ n) $\to$ (i $\leq$ n). allowing us only needing to prove:\\
            ((r = f(i)) $\land$ (x = f(i -1)) $\land$ (i $<$ n) $\land$ (n $\geq$ 1)) $\to$ ((f(i + 1) = r + x) $\land$ (f(i) = x) $\land$ (i $\leq$ n) $\land$ (n $\geq$ 1))\\    
            To prove this we essentially need a proof that in the Fibonacci sequence:\\
            If f(i) = r and f(i - 1) = x then that means f(i + 1) = r + x for all Fibonacci numbers greater than or equal to 1.\\
            Essentially we are proving f(i + 1) = f(i) + f(i - 1) however, since i $<$ n and f(0) is defined aswell as f(1) we can substitute i - 1 into the expression to achieve\\
            f(i) = f(i - 1) + f(i - 2) which is our definition of the Fibonacci sequence.
    \end{list}
    
    \begin{list}
        \item {Proof for Line 15 - (TRUE $\land$ (n $\geq$ 1)) $\to$ (init $\land$ (1 = f(1)) $\land$ (0 = f(0)))}
        (TRUE $\land$ (n $\geq$ 1)) $\to$ (init $\land$ (1 = f(1)) $\land$ (0 = f(0)))\\
        So our proof becomes:\\
        show 1 = f(1) and 0 = f(0) is true. As can be seen init and n $\geq$ 1 are equivalent. From our definition of the Fibonacci sequence, f(0) = 0 and f(1) = 1. So this is true.
    \end{list}
    
    \begin{list}
        \item {Proof for Line 17 - (invariant $\land$ (r = f(i)) $\land$ (i $\geq$ n)) $\to$ r = f(n)}
        (invariant $\land$ (r = f(i)) $\land$ (i $\geq$ n)) $\to$ r = f(n)\\
        So our proof becomes:\\
        Show that i = n by the end of the loop to get f(n) by substitution. We have i $\geq$ n and our invariant states that r = f(i) and x = f(i - 1) and i $\leq$ n. By combining the fact that i $\leq$ n and that i $\geq$ n in our first part of the implication this can be shown to be true. Using a variation of squeezes theorem, if n $\geq$ i $\leq$ n then i = n. in a less formal way to put it, i is less than or equal to a number and greater than or equal to the same number, then i is that number. This gives us i = n, and r = f(n), allowing for post condition weakening. 
    \end{list}
    Therefore our proof is complete, since we have derived\{TRUE $\land$ n $\geq$ 1\} Fib \{r = f(n)\}. Assuming our program Fib terminates we get the following deduction:\\ Since this was deduced with no presumptions that means everything deduces to the following\\
    \hspace*{150pt}$\vdash$ \{n $\geq$ 1\} Fib \{r = F(n)\}
    \newpage
    \item Annotate your code with the necessary assertions so that your proof can be reconstructed. \moveToRight{3 marks}\\\\
   For this solution conditions have been compacted in the following:\\ \{init\} = \{n $\geq$ 1\}\\
    \{invariant\} = \{(f(i) = r) $\land$ (f(i - 1) = x) $\land$ (i $\leq$ n) $\land$ (\{init\})\}\\
    \{updateRpre\} = \{(f(i + 1) = r + x) $\land$ (f(i) = r) $\land$ (i $\leq$ n) $\land$ (n $\geq$ 1)\} note f(i) = (r + x) - x\\
    \{updateRpost\} =  \{(f(i + 1) = r) $\land$ (f(i) = r - x) $\land$ (i  $\leq$ n) $\land$ (n $\geq$ 1)\}\\
    \{updateXpost\} =  \{(f(i + 1) = r) $\land$ (f(i) = x) $\land$  (i $\leq$ n) $\land$ (n $\geq$ 1)\}\\\\  
    Using our derivation from our Hoare logic above we can annotate the code in the following (without the comments from (a)):\\
\begin{lstlisting}[language=Maple,mathescape=true]
                    //{True n $\geq$ 1}
x := 0;             //{f(0) = 0}
r := 1;             //{f(1) = 1}
i := 1;             //{r = f(i)}
while y < n do      //{invariant}
                    //{updateRpre}
    r := r + x;     //{updateRpost}
    x := r - x;     //{updateXpost} 
    i := i + 1;     //{invariant}
od                  //{r = f(i) $\land$ invariant $\land$ i $\geq$ n}
                    //{r = f(n)}
    \end{lstlisting}
    \textbf{Bonus:} Adjust your proof to show that your code terminates. \moveToRight{3* marks}\\\\
    Solution:\\
    To show that the code terminates we can use a variant V which is a formula that computes to a value that begins as positive, and we need to show that this value keeps decreasing on each iteration of the loop. a suitable variant to achieve this would be V := (n - i). By using this we can change the annotations on the code above to prove termination (note that since the annotated code is a direct application of the Hoare logic derivation, this can also be applied to the Hoare logic proof).
\begin{lstlisting}[language=Maple,mathescape=true]
                    //{True n $\geq$ 1}
x := 0;             //{f(0) = 0}
r := 1;             //{f(1) = 1}
i := 1;             //{r = f(i)}
while i < n do      //{invariant $\land$ V = (n - i)}
                    //{updateRpre $\land$ V = (n - i)}
    r := r + x;     //{updateRpost $\land$ V = (n - i)}
    x := r - x;     //{updateXpost $\land$ V = (n - i)} 
    i := y + 1;     //{invariant $\land$ V < (n - i)}
od                  //{r = f(i) $\land$ invariant $\land$ i $\geq$ n}
                    //{r = f(n)}
\end{lstlisting}
However we have two proof obligations before this proof can be complete\\\\
 \begin{list}
        \item {show  (V := (n - i)) $>$ 0 before entering loop}
        Given that n $\geq$ 1 from our initial conditions and that i $\leq$ n from our loop invariant then (n - i) $\geq$ 0 since n is larger than i, and n is also positive.  
    \end{list}
 \begin{list}
        \item {show [V := n - i] i = i + 1 [(V :=  $<$ (n - i)]}
        on the precondition we get [v := n - (i + 1)]. Expanding out we get [v := (n - i - 1)]. as can be seen (n - i - 1)  $<$ (n - i)   
    \end{list}
Another way to phrase our variant, is that since v := n - i and our value i increments by one on each loop iteration, i $<$ n and n does not change, we reach a state where v = 0 after i iterations. This completes the proof showing in fact our program Fib will terminate if n $\geq$ 1.
\end{enumerate}

\newpage
\section{appendix}
To run this code used in Section 2 
\begin{enumerate}[1. ]
    \item Copy and paste all the code into files an editor of choice using the same class names
    \item Make sure all files are in the same directory!
    \item javac *.java
    \item java Test
\end{enumerate}

Channel.java (name the file Channel.java)
\begin{lstlisting}
public class Channel{

    public int id;

    public Channel(int ID){
        this.id = ID;
    }

    public int get_Id(){
        return this.id;
    }
}
\end{lstlisting}

Network.java (name the file Network.java)
\begin{lstlisting}
import java.util.*;

public class Network {

    public String name;
    public Channel connected;
    public ArrayList<String> close_proximity_networks;

    public Network(String name, Channel connected, ArrayList<String> close_proximity_networks) {
        this.name = name;
        this.connected = connected;
        this.close_proximity_networks = close_proximity_networks;
    }

    public String get_name() {
        return this.name;
    }

    public Channel get_channel() {
        return this.connected;
    }

    public ArrayList<String> get_close_proximity_networks() {
        return this.close_proximity_networks;
    }
}
\end{lstlisting}
Predicate.java (name the file Predicate.java)
\begin{lstlisting}
import java.util.*;

public class Predicates{

    public Network connected_to_all1 = null;
    public Network connected_to_all2 = null;
    public Network unique1 = null;
    public Network unique2 = null;
    public ArrayList<Network> all_networks;
    public ArrayList<Channel> all_channels;
    public Predicates(ArrayList<Network> networks, ArrayList<Channel> channels){
        this.all_networks = networks;
        this.all_channels = channels;
    }

    public boolean is_close_proximity(Network n1, Network n2){
        //anti-reflexive property by not letting n1 = n2 be true
        //i.e. if the two networks are the same return false!
        if(n1 == n2){
            return false;
        }
        //adding the symmetric relation by making n1 close proximity to n2
        if(n2.get_close_proximity_networks().contains(n1.get_name())){
            return true;
        }
        //if the network name is apart of the other networks close proximity network list then return true
        if(n1.get_close_proximity_networks().contains(n2.get_name())){
            return true;
        }
        //return false otherwise
        return false;
    }

    public boolean valid_configuration(Network n1, Network n2){
        //if the two networks are in close proximity then we check the channels are different to return true
        if(is_close_proximity(n1, n2)){
            //both networks use different channels
            return n1.get_channel().get_Id() != n2.get_channel().get_Id();
        }
        //if the channels are not in close proximity then it is valid eitherway
        return true;
    }

    //this allows use to now modify all_valid configuration to the following
    //since we now have anti-reflexive inside our close proximity rather than in the predicate all_configurations_valid we can just simply call valid_configuration(n1,n2)
    public boolean all_configurations_valid(){
        //we want to check all possible configurations
        for(Network n1 : all_networks){
            for(Network n2 : all_networks){
                //if ANY configuration is invalid we return false as the setup is invalid
                if(!valid_configuration(n1, n2)){
                    return false;
                }
            }
        }
        //return true if it does not exit the loop with return false
        return correct_sizes() && two_connected_to_all() && two_unique_connected();
    }

    //our predicate to make sure we have the correct amount of networks and channels
    public boolean correct_sizes(){
        return (all_networks.size() == 4 && all_channels.size() == 3);
    }

    //our predicate to make sure we have only two networks which are in close proximity to all other networks
    public boolean two_connected_to_all(){
        //this flag will be used to be a check if the network is
        //in close proximity to all other networks
        //if a network is not in close proximity to any network we want to go to the next
        //network as this one is not connected to ALL networks. we reset the flag at each iteration
        //if the flag is false.
        boolean flag = true;
        //count how many networks are connected to ALL networks
        int count = 0;
        //scan through all combinations of the networks
        for(Network n1 : all_networks){
            for(Network n2 : all_networks){
                //if n1 is not in close proximity to all other networks we want to set flag as false
                //and go to the next network
                if(!is_close_proximity(n1, n2) && n1 != n2){
                    flag = false;
                    break;
                }
            }
            //if the flag is false that means we dont want to increase the counter or update
            //our class vairables
            if(flag == false){
                flag = true;
                continue;
            }
            //otherwise we want to set the class variables in order
            if(connected_to_all2 == null && connected_to_all1 != null){
                connected_to_all2 = n1;
            }

            if(connected_to_all1 == null){
                connected_to_all1 = n1;
            }
            //and increment the count
            count++;
        }
        //return the statement that the count must be exactly 2
        //and that the two networks connected to all the other networks
        //are not the same network
        return (count == 2) && (connected_to_all1 != connected_to_all2);
    }

    //our predicate to make sure that the other two networks are also connected to the other networks
    //that connect to everything and are not connected to any other node
    public boolean two_unique_connected(){
        //if we don't have two networks which are connected to all other networks
        if(null == connected_to_all1 || null == connected_to_all2) {
            return false;
        }
        //otherwise we want to isolate the other 2 networks and make sure they are
        //1. connected to the connected_to_all networks AND
        //2. those two networks are not connected to each other
        //3. those two networks are not the same network
        Network n1 = null;
        Network n2 = null;
        //find the two networks which are not the ones connected to the rest of the networks
        for(Network n : all_networks){
            if(n1 != null && (n != connected_to_all1 && n != connected_to_all2) && n2 == null){
                n2 = n;
            }
            if((n != connected_to_all1 || n != connected_to_all2) && n1 == null){
                n1 = n;
            }
        }
        //if those two networks are NOT in close proximity with ONLY the two networks that are connected
        //to the rest, we return false
        if(n1.get_close_proximity_networks().size() != 2 && n2.get_close_proximity_networks().size() != 2){
            return false;
        }
        //if those two networks are in close proximity to each other
        //return false
        if(is_close_proximity(n1, n2)){
            return false;
        }
        //if the network is not in close proximity with the two networks
        //connected to the all networks, return false
        if(!n1.get_close_proximity_networks().contains(connected_to_all2.get_name()) &&
                !n1.get_close_proximity_networks().contains(connected_to_all1.get_name())){
            return false;
        }
        if(!n2.get_close_proximity_networks().contains(connected_to_all2.get_name()) &&
                !n2.get_close_proximity_networks().contains(connected_to_all1.get_name())) {
            return false;
        }
        //otherwise return true since it has passed all checks
        unique1 = n1;
        unique2 = n2;
        return true;
    }

}
\end{lstlisting}

Test.java (name the file Test.java)
\begin{lstlisting}
import java.util.*;

public class Test {
    public static void main(String args[]) {
        Channel low = new Channel(0);
        Channel medium = new Channel(1);
        Channel high = new Channel(2);

        ArrayList<String> close_proximity_to_a = new ArrayList<String>();
        close_proximity_to_a.add("B");
        close_proximity_to_a.add("D");
        Network A = new Network("A", medium, close_proximity_to_a);

        ArrayList<String> close_proximity_to_b = new ArrayList<String>();
        close_proximity_to_b.add("A");
        close_proximity_to_b.add("C");
        close_proximity_to_b.add("D");
        Network B = new Network("B", high, close_proximity_to_b);

        ArrayList<String> close_proximity_to_c = new ArrayList<String>();
        close_proximity_to_c.add("B");
        close_proximity_to_c.add("D");
        Network C = new Network("C", medium, close_proximity_to_c);

        ArrayList<String> close_proximity_to_d = new ArrayList<String>();
        close_proximity_to_d.add("A");
        close_proximity_to_d.add("B");
        close_proximity_to_d.add("C");
        Network D = new Network("D", low, close_proximity_to_d);

        ArrayList<Channel> channels = new ArrayList<Channel>();
        channels.add(low);
        channels.add(medium);
        channels.add(high);

        ArrayList<Network> networks = new ArrayList<Network>();
        networks.add(A);
        networks.add(B);
        networks.add(C);
        networks.add(D);

        Predicates check = new Predicates(networks, channels);
        System.out.println("Correct size of configuration 4 networks 3 channels : " + check.correct_sizes());
        System.out.println("Only two networks connected to all other networks: " + check.two_connected_to_all());
        System.out.println("Two networks connected to the ones above but not to each other: " + check.two_unique_connected());
        System.out.println("Final valid configuration (main requirements): " + check.all_configurations_valid());
        System.out.println("A connected to : " + A.get_close_proximity_networks());
        System.out.println("B connected to : " + B.get_close_proximity_networks());
        System.out.println("C connected to : " + C.get_close_proximity_networks());
        System.out.println("D connected to : " + D.get_close_proximity_networks());
        System.out.println("The two channels which were connected to all other channels satisfying psi_6 are : "
                + check.connected_to_all1.get_name() + " and "
                + check.connected_to_all2.get_name());
        System.out.println("The two channels which are unique satisfying psi_7 are : "
                + check.unique1.get_name() + " and " + check.unique2.get_name());
    }
}

\end{lstlisting}

\end{document}
