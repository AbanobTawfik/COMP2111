\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs} % for "\midrule" macro
\usepackage{lipsum} % for filler text
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{array}
\usepackage{lplfitch}
\usepackage{hyperref}
\usepackage{caption}
\usepackage{bbm}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
%note this LaTeX package was not written by me and taken from stackexchange forums to be used to write java code formatted
%link to original page https://stackoverflow.com/questions/3175105/inserting-code-in-this-latex-document-with-indentation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%note this LaTeX package was not written by me and taken from stackexchange forums to be used to write z3 code formatted
%link to original page https://github.com/mewmew/latex/blob/master/z3/lang.sty
\lstdefinelanguage{z3}{
	sensitive=true,
	alsoletter={\-},
	% comments.
	%    ; line comment
	comment=[l]{;},
	% Z3 keywords.
	keywords=[1]{
apply, assert, assert-soft, check-sat, check-sat-using, compute-interpolant,
declare-const, declare-datatypes, declare-fun, declare-map, declare-rel,
declare-sort, declare-tactic, define-sort, display, echo, eval, exit,
fixedpoint-pop, fixedpoint-push, get-assertions, get-assignment, get-info, get-
interpolant, get-model, get-option, get-proof, get-unsat-core, get-user-tactics,
get-value, help, help-tactic, labels, maximize, minimize, pop, push, query,
reset, rule, set-info, set-logic, set-option, simplify
	},
	% Z3 built-ins
	morekeywords=[2]{
check-sat-using, declare-var, declare-rel, rule, query, set-predicate-
representation, maximize, minimize, assert-soft, assert-weighted, compute-
interpolant
	},
}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*\moveToRight[1]{\hspace*{0em plus 1fill}\makebox{(#1)}}
\newcommand*\fixindent{ \hspace{1pt}\\}
%this command below is not my work was used for quality of life
%link to original post 
%https://tex.stackexchange.com/questions/330588/how-to-produce-given-number-of-quad-in-math
\newcommand{\myquad}[1][1]{\hspace*{#1em}\ignorespaces}
\title{Assignment Two}
\author{Abanob Tawfik\\z5075490}
\date{March 2019}

\begin{document}
\maketitle
\section{Problem 1}
The skip command is an $\mathcal{L}$  program that has the effect of “do nothing”. That is, skip; P has the same behaviour as P;skip and the same behaviour as P.
\begin{enumerate}[(a)]
    \item Define skip using the default $\mathcal{L}$ commands – that is, write an $\mathcal{L}$ program for skip. \moveToRight{3 marks}\\\\
    Solution: \\
    A very simple and short program to achieve this could be assigning a variable to itself, in turn having no effect on the current state of the program.
    \begin{lstlisting}[language=Maple,mathescape=true]
x := x;
    \end{lstlisting}
    by setting the variable to itself when the following program is executed we have not modified our state and this has no effect. 
    
    \item Based on your definition and the rules of denotational semantics discussed in lectures, determine the semantic object $[\![$skip$]\!]$. \moveToRight{4 marks}\\\\
    Solution: \\
    The semantic object $[\![$skip$]\!]$ also defined as $[\![$x := x$]\!]$  can be defined by the following:\\
    $[\![$skip$]\!]$ = \{($\eta$,$\eta'$) if and only if $\eta'$ = $\eta$[x$\mapsto$ $[\![x]\!]^\eta$\}].\\
    The binary predicate for our semantic object $[\![$skip$]\!]$ will always be true in any state as this can simply be seen as a loop to the current state since we are not modifying our state.
    
    
    \item Suppose skip was a default command in L. Propose a suitable rule for Hoare Logic that handles skip. \moveToRight{3 marks}\\\\
    Solution: \\
    Since our program skip has the effect of doing nothing, we can define our program skip having the same pre and post condition in the following:\\
    Suppose our program is in the state $\psi$, then our skip program can be given the Hoare Logic rule
    \begin{center}
        \{$\psi$\} skip \{$\psi$\}.\\
    \end{center}
\end{enumerate}

\newpage
\section{Problem 2}
Recall the diagonally-moving robot example from the lectures: from position (x, y) the robot can move to\\
any of: (x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1).
\begin{enumerate}[(a)]
    \item Write a program in $\mathcal{L}^{+}$ that, on termination, will confirm that a location (m, n) is reachable by the robot starting at (0, 0). That is, the program Reach should be such that the Hoare triple
    \begin{center}\{(x = 0) $\land$ (y = 0)\} REACH \{(x = m) $\land$ (y = n)\}\end{center}
    is valid if and only if (m, n) is reachable from (0, 0). Note: your program does not have to terminate.\moveToRight{14 marks}\\\\
    Solution:\\
    For this solution to save space i will use labels for each transition in the following:\\
    NE = (x := x + 1; y := y + 1;)\\
    SE = (x := x + 1; y := y - 1;)\\
    NW = (x := x - 1; y := y + 1;)\\
    SW = (x := x - 1; y := y = 1;)\\
    guard = $\neg$((x = m) $\land$ (y = n))
    \begin{lstlisting}[language=Maple,mathescape=true]
x := 0;
y := 0;
// program for reach starts here!!!
// if this program were to be written in $\mathcal{L}$ then we would have a loop
// which exits when x = m and y = n, and on each iteration we would check that 
// our transition for x and y gets us closer to the goal, however since $\mathcal{L}^{+}$
// is non-deterministic we can make our program choose between all transitions
(guard;NE + SE + NW + SW)*;$\neg$guard;
    \end{lstlisting}    
The above program was written purely in $\mathcal{L}^{+}$, however it can also be written below using a while loop to make it more clear what is going on. I will not be using this program below for the Hoare logic derivation, i will be using the above which was written purely in $\mathcal{L}^{+}$.
    \begin{lstlisting}[language=Maple,mathescape=true]
x := 0;
y := 0;
// program for reach starts here!!!
while guard do
// non deterministically choose our next transition
    (NE + SE + NW + SW);
od;
    \end{lstlisting}   
    
    A quick explanation of the program:\\
    Since the program is written in $\mathcal{L}^{+}$, we can utilise non-determinism to choose the transition that optimally reaches the goal state. We create a loop which has the guard x is not equal to m and y is not equal to n, and within the loop we will constantly perform transitions non-deterministically. IF the program terminates (successful exit of while loop) then we have the statement $\neg$guard, which ends up being $\neg\neg$((x = m) $\land$ (y = n)). By using double negation elimination, we end up with x = m $\land$ y = n if and only if the program terminates. The first program was written purely in  $\mathcal{L}^{+}$, however the second program was written using the while rule from  $\mathcal{L}$ and the remaining written in $\mathcal{L}^{+}$. This was done because in the second program it is clearer to see how the transitions occur within the loop where it may not be as obvious in the first program. Note that also termination will only occur when m + n is even. Due to the nature of movement, we begin on tile 0 + 0 which is even. Movement in transition x + 1; y + 1, we get a total change of 2 which is also even. Movement in transition x - 1; y - 1, we get a total change of -2 which is also even. Movement in transition x + 1; y - 1, we get a total change of 0 which is also even. Movement in transition x - 1; y + 1, we get a total change of 0 which is also even. Since our initial state (0, 0) has x + y = 0, and all transitions have an even net change (0, 2, -2) this means we can only move to states where x + y is even. 


    \item Prove that your program is correct (i.e. show the validity of the above Hoare triple). Annotating your code with appropriate assertions, as long as the proof is recoverable, is sufficient. \moveToRight{6 marks}\\\\
    Solution:\\
    To perform this proof we will first acquire our Hoare logic derivation, and use this annotation to annotate the programs. For this solution conditions have been compacted in the following:\\
    \{invariant\} = \{(x + y) $\mod$ 2 = 0\}\\
    NE = (x := x + 1; y := y + 1;)\\
    SE = (x := x + 1; y := y - 1;)\\
    NW = (x := x - 1; y := y + 1;)\\
    SW = (x := x - 1; y := y = 1;)\\
    guard = $\neg$((x = m) $\land$ (y = n))
    \begin{enumerate}[1. ]
        \item \{0 = 0\} x := 0 \{x = 0\} \moveToRight{assignment inference rule}
        \item \{0 = 0\} y := 0 \{y = 0\} \moveToRight{assignment inference rule}
        \item \{0 = 0 $\land$ 0 = 0\} x := 0; y := 0 \{x = 0 $\land$ y = 0\} \moveToRight{assignment inference rule}
        \item \{invariant\} x := x + 1; \{$\neg$((x + y) $\mod$ 2 = 0)\} \moveToRight{proof obligation}
        \item \{$\neg$((x + y) $\mod$ 2 = 0)\} y := y + 1; \{invariant\}
        \moveToRight{proof obligation}
        \item \{invariant\} x := x + 1; y := y + 1; \{invariant\}
        \moveToRight{sequence inference rule: 4, 5}
        \item \{invariant\} NE \{invariant\} \moveToRight{substitution}
        \item \{invariant\} x := x + 1; \{$\neg$((x + y) $\mod$ 2 = 0)\} \moveToRight{proof obligation}
        \item \{$\neg$((x + y) $\mod$ 2 = 0)\} y := y - 1; \{invariant\}
        \moveToRight{proof obligation}
        \item \{invariant\} x := x + 1; y := y - 1; \{invariant\}
        \moveToRight{sequence inference rule: 8, 9}
        \item \{invariant\} SE \{invariant\} \moveToRight{substitution}
        \item \{invariant\} x := x - 1; \{$\neg$((x + y) $\mod$ 2 = 0)\} \moveToRight{proof obligation}
        \item \{$\neg$((x + y) $\mod$ 2 = 0)\} y := y + 1; \{invariant\}
        \moveToRight{proof obligation}
        \item \{invariant\} x := x - 1; y := y + 1; \{invariant\}
        \moveToRight{sequence inference rule: 12, 13}
        \item \{invariant\} NW \{invariant\} \moveToRight{substitution}
        \item \{invariant\} x := x - 1; \{$\neg$((x + y) $\mod$ 2 = 0)\} \moveToRight{proof obligation}
        \item \{$\neg$((x + y) $\mod$ 2 = 0)\} y := y - 1; \{invariant\}
        \moveToRight{proof obligation}
        \item \{invariant\} x := x - 1; y := y - 1; \{invariant\}
        \moveToRight{sequence inference rule: 16, 17}
        \item \{invariant\} SW \{invariant\} \moveToRight{substitution}
        \item \{invariant\} NE + SE \{invariant\} \moveToRight{choice inference rule: 7, 11}
        \item \{invariant\} NE + SE + NW\{invariant\} \moveToRight{choice inference rule: 20, 15}
        \item \{invariant\} NE + SE + NW + SW\{invariant\} \moveToRight{choice inference rule: 21, 19}
        \item \{invariant $\land$ guard\} (NE + SE + NW + SW)* \{invariant $\land$ guard\} \moveToRight{Loop inference rule: 22}
        \item \{invariant $\land$ guard\} LOOP \{invariant $\land$ $\neg$guard\} \moveToRight{Loop sequence in $\mathcal{L}^{+}$: 23}
        \item \{x = 0 $\land$ y = 0\} REACH \{invariant $\land$ $\neg$ guard\} \moveToRight{seq}
        \item (invariant $\land$ $\neg$guard)$\to$(x = m $\land$ y = n) \moveToRight{proof obligation}
        \item \{x = 0 $\land$ y = 0\} REACH \{x = m $\land$ y = n\} \moveToRight{consequence inference rule: 25, 26}        
    \end{enumerate}
    Proof obligations used in the Hoare logic derivation:
    In the Hoare logic we assume our invariant holds before the loop begins, since x + y = 0 + 0 = 0 which is also even! 0 $\mod$ 2 = 0.
    Note our substitutions are the following:\\
    \{invariant\} = \{(x + y) $\mod$ 2 = 0\}\\
    NE = (x := x + 1; y := y + 1;)\\
    SE = (x := x + 1; y := y - 1;)\\
    NW = (x := x - 1; y := y + 1;)\\
    SW = (x := x - 1; y := y = 1;)\\
    guard = $\neg$((x = m) $\land$ (y = n))\\
    
    \begin{list}
        \item {Proof for Line 4 and line 5}
        Line 4 - \{invariant\} x := x + 1; \{$\neg$((x + y) $\mod$ 2 = 0)\}\\
        And\\
        Line 5 - \{$\neg$((x + y) $\mod$ 2 = 0)\} y := y + 1; \{invariant\}\\
        An informal way for the proof obligation:\\
       On line 4 before execution we have x + y is even, then when we add 1 to x, and x + y is no longer even. This is because adding 1 to an even number will make it odd. after we add 1 to y on line 5, we get x + y is even again because when we add 1 to an odd number we get an even number. More formally this can be shown as:\\\\
        Line 4 - \{invariant\} x := x + 1; \{$\neg$((x + y) $\mod$ 2 = 0)\}\\
        initially we have our invariant (x + y) $\mod$ 2 = 0.
        Then we add 1 to x, so if we add 1 on both sides we get (x + y) $\mod$ 2 = 1 (note x = x + 1 after x := x + 1 execution). Since (x + y) $\mod$ 2 = 1, this also implies $\neg$((x + y) $\mod$ 2 = 0).\\\\
        Line 5 - \{$\neg$((x + y) $\mod$ 2 = 0)\} y := y + 1; \{invariant\}\\
        initially we have $\neg$((x + y) $\mod$ 2 = 0) which also as shown above is equivalent to (x + y) $\mod$ 2 = 1, since any number mod 2 can only be 0 or 1. after execution of y := y + 1, if we add 1 to both sides we get (x + y) $\mod$ 2 = 0 which is also our invariant.
    \end{list}
    The proof method above is used for the following proof obligations:
    \begin{itemize}
        \item Line 8 and Line 9
        \item Line 12 and Line 13
        \item Line 17 and Line 18
    \end{itemize}
    \newpage
    Since each transition follows the same manner, where the total distance changed is either $\pm$ 2 or 0 the change can be seen in the following for all transitions:
    \begin{itemize}
        \item (x + 1, y + 1) NE change = 1 + 1 = 2 (even)
        \item (x + 1, y - 1) SE change = 1 - 1 = 0 (even)
        \item (x - 1, y + 1) NW change = 1 - 1 = 0 (even)
        \item (x - 1, y - 1) SW change = -1 - 1 = -2 (even)
    \end{itemize}
    Also note the definition of an even is (even number) $\mod$ 2 = 0.
    
     \begin{list}
        \item {proof for line 26}
        Line 26 - (invariant $\land$ $\neg$guard)$\to$(x = m $\land$ y = n)\\
        using our substitution we can get\\
        (((x + y) $\mod$ 2 = 0) $\land \neg$($\neg$(x = m $\land$ y = n))) $\to$ (x = m $\land$ y = n).\\ We can use and elimination to simplify down to\\
        ($\neg$($\neg$(x = m $\land$ y = n)) $\to$ (x = m $\land$ y = n)\\
        This is simply just a proof of double negation elimination which is done by natural \\deduction.\\
        \fitchprf{\pline[1.]{$\neg\neg \psi$}}{
            \subproof{\pline[2.]{$\neg \psi$}}{
                \pline[3.]{$\bot$}\lfalsei{1}{2}
            }
            \pline[4.]{\psi}[IP: 1-3]
        }\\
        As shown by natural deduction $\neg\neg$(x = m $\land$ y = n) $\to$ (x = m $\land$ y = n).
        (note our loop will never terminate if our invariant doesn't hold (if m + n is not even it will never terminate).
    \end{list}
By using our Hoare logic deduction for our program in $\mathcal{L}^{+}$ we can annotate our program in the following: (please note our program will not terminate if m + n is not even as it will never be able to transition to a tile on those coordinates, we can add a if statement if need be to assure termination is always possible).\\
The proof will be performed in the next page so it is not split between pages.
\newpage
ALSO NOTE i will be expanding out my substitutions NE, SE, NW, SW for this proof, and the following will be substituted for the proof:\\
    guard = $\neg$((x = m) $\land$ (y = n))\\
    invariant = (x + y) $\mod$ 2 = 0.\\
    \begin{lstlisting}[language=Maple,mathescape=true]
                                        //{0 = 0}
x := 0;                                 //{x = 0}
y := 0;                                 //{y = 0}
// program for reach starts here!!!
                                        //{x = 0 $\land$ y = 0}
(guard;
                                        //{invariant}
(x := x + 1;                            //{$\neg$((x + y) mod 2 = 0)}
y := y + 1);                            //{invariant}
+                                       //{invariant} 
(x := x + 1;                            //{$\neg$((x + y) mod 2 = 0)}
y := y - 1);                            //{invariant}
+                                       //{invariant}
(x := x - 1;                            //{$\neg$((x + y) mod 2 = 0)}
y := y + 1);                            //{invariant}          
+                                       //{invariant}
(x := x - 1;                            //{$\neg$((x + y) mod 2 = 0)}
y := y - 1);)*;                         //{invariant}
$\neg$guard;                                  //{x = m $\land$ y = n}

    \end{lstlisting} 
using our substitutions NE, SE, NW, SW we can simply further to get the exact same proof
    \begin{lstlisting}[language=Maple,mathescape=true]
                                        //{0 = 0}
x := 0;                                 //{x = 0}
y := 0;                                 //{y = 0}
// program for reach starts here!!!
                                        //{x = 0 $\land$ y = 0}
(guard;
                                        //{invariant}
NE                                      //{invariant}
+                                        
                                        //{invariant}
SE                                      //{invariant}
+                                       
                                        //{invariant}
NW                                      //{invariant}
+       
                                        //{invariant}
SW);)*;                                 //{invariant}
$\neg$guard;                                  //{x = m $\land$ y = n}

    \end{lstlisting}
\end{enumerate}

\newpage
\section{Problem 3}
Suppose you have ten coins arranged in a line. A move consists of taking any three adjacent coins and turning them over (changing heads to tails and vice-versa). For example, if the coins were arranged as:
\begin{center}\textit{HHTTHTHTHT}\end{center}
one move could be to flip the second, third and fourth coins to get the arrangement:
\begin{center}\textit{HTHHHTHTHT}\end{center}
\begin{enumerate}[(a)]
    \item Model this situation as a transition system, carefully defining your states and the transition relation. \moveToRight{4 marks}\\\\
    Solution:\\
    To model this problem, we can use a Boolean form representation of the coins, true = heads, false = tails and have 10 Boolean values cross product with the integers 1-10 for position, so each element of our set is a boolean for head/tails and a integer for position 0-9
    \\for our transition system
    $S$ = \{a, b, c, d, e, f, g, h, i, j\} where a, b, c, d, e, f, g $\in \mathbb{B}\times[1,10]$ 
    for example the initial state above could be the following:\\
    \{(true,1), (true,2), (false,3), (false,4), (true,5), (false,6), (true,7), (false,8), (true,9), (false,10)\}
    Our transition relation $\rightarrow$ can be defined as taking three adjacent elements of our set and flipping the Boolean expression using !.\\
    $\rightarrow$ is given by
    \begin{itemize}
        \item (a = (!bool), 1)) $\land$ (b = (!bool, 2)) $\land$ (c = (!bool), 3))
        \item (b = (!bool), 2)) $\land$ (c = (!bool, 3)) $\land$ (d = (!bool), 4))
        \item (c = (!bool), 3)) $\land$ (d = (!bool, 4)) $\land$ (e = (!bool), 5))
        \item (d = (!bool), 4)) $\land$ (e = (!bool, 5)) $\land$ (f = (!bool), 6))
        \item (e = (!bool), 5)) $\land$ (f = (!bool, 6)) $\land$ (g = (!bool), 7))
        \item (f = (!bool), 6)) $\land$ (g = (!bool, 7)) $\land$ (h = (!bool), 8))
        \item (g = (!bool), 7)) $\land$ (h = (!bool, 8)) $\land$ (i = (!bool), 9))
        \item (h = (!bool), 8)) $\land$ (i = (!bool, 9)) $\land$ (j = (!bool), 10))
    \end{itemize}
    
    
    
    \item By considering the coins in positions 1,2,4,5,7,8, and 10 (i.e. positions not divisible by 3) find a preserved invariant of this system. \moveToRight{4 marks}\\\\
    Solution:\\
    A preserved invariant of this system would be that the coins in position 1, 2, 4, 5, 7, 8, 10 (positions not divisible by 3) preserve the parity for head and tails regardless of state change. For example is position 1, 2, 4, 5, 7, 8 and 10 have an even number of heads and an odd number of tails, then regardless of state change this will always remain true. Also note that heads and tails cannot have the same parity for these positions since there are 7 positions. 
    A formal way to put this is:\\
    let parity\_of\_heads be the variable that has the parity of the number of heads at the initial state in position 1, 2, 4, 5, 7, 8, 10.\\\\
    let parity\_of\_tails be the variable that has the parity of the number of tails at the initial state in position 1, 2, 4, 5, 7, 8, 10.\\
    let $\psi_1$ be the proposition that parity\_of\_heads remains the same on each transition.\\
    let $\psi_2$ be the proposition that parity\_of\_tails remains the same on each transition. \\
    Our invariant is $\psi$ = $\psi_1$ $\land$ $\psi_2$.
    This is because on each move, we will always modify 2 of the coins in the position 1, 2, 4, 5, 7, 8 and 10. This can be seen in each transition in part (a). Since we always modify 2 of the coins we can check each combination of HH, TT, HT/TH to verify that this property will always remain true.\\
    If we have HH, if we swap to TT, the parity will stay the same as a subtraction of 2 for T and addition of 2 to H will have no effect on parity because 2 $\mod$ 2 = 0. 
    If we have TT, if we swap to HH, the parity will stay the same as a subtration of 2 will have no effect on parity, similair to the reason above
    If we have HT/TH, if we swap the parity to TH/HT this will also have no effect on the parity as our net change will be 0, we are simply swapping Heads to tails and tails to head so our number of heads and tails in those position stay the same and our parity remains the same.\\
    Therefore our invariant is true, and was proven using proof of cases.
        
    \item Show that the arrangement \textit{TTTTTTTTTT} is not reachable from the arrangement \\\texit{HHHHHHHHHH}. \moveToRight{2 marks}\\\\
    Solution:\\
    The arrangement \textit{TTTTTTTTTT} is not reachable from \texit{HHHHHHHHHH}. This is because in our initial arrangement \texit{HHHHHHHHHH}, The number of heads in position 1, 2, 4, 5, 7, 8, 10 is 7, 7$\mod$2 = 1 so the parity of our heads is odd. The number of tails in those positions is also 0 which is even. Due to our invariant $\psi$ which states that the parity of heads and parity of tails in those positions remain the same on each move, we can never reach the state \textit{TTTTTTTTTT}, because in that state, the number of tails in those position is 7 which is odd, however our number of tails in those position MUST BE EVEN due to our invariant $\psi$.
\end{enumerate}

\newpage
\section{Problem 4}
Let $\Sigma$ = \{0,1\}$^3$, so each element of $\Sigma$ is a triple of symbols that are either 0 or 1.\\ Let $f, s, t : \Sigma^* \to \{0, 1\}^*$ be the functions that take a word from $\Sigma^*$ and return the word of \{0,1\}$^*$ that is defined by considering only the symbols in the first, second or third (respectively) component. So if w = 
$\bigl(\begin{smallmatrix}
    0\\
    0\\
    0\\
\end{smallmatrix}\bigr)
\bigl(\begin{smallmatrix}
    1\\
    1\\
    0\\
\end{smallmatrix}\bigr)
\bigl(\begin{smallmatrix}
    1\\
    0\\
    1\\
\end{smallmatrix}\bigr)
\bigl(\begin{smallmatrix}
    0\\
    1\\
    0\\
\end{smallmatrix}\bigr)$, then $f(w)$ = 0110, $s(w)$ = 0101 and $t(w)$ = 0010. Finally let \\$bin$ : \{0,1\}$^*$ $\to$ $\mathbbm{N}$ be the function that treats a word of \{0,1\}$^*$ as the binary representation of a non-negative integer, with the last symbol being the least-significant.\\ So $bin$(110) = $bin$(00110) = 6 and $bin$($\lambda$) = 0.\\
Design a DFA that acceptes the following language:
\begin{center}
\{w $\in$ $\Sigma^*$ : $bin$($t$(w)) = $bin$($f$(w)) + $bin$($s$(w))\}.\\ \moveToRight{10 marks}\\    
\end{center}\\Solution:\\
The way we will be representing the input will be through a three digit integer (eg.) 010 represents $\bigl(\begin{smallmatrix}
    0\\
    1\\
    0\\
\end{smallmatrix}\bigr)$.\\
\textbf{PLEASE NOTE I COULD NOT FIT ALL POSSIBLE STATES SO ANY INPUT WHICH DOES NOT FOLLOW A TRANSITION WILL BE ASSUMED TO BE TAKEN TO A ERROR STATE (a non-final state) LOOPING TO ITSELF ON WHATEVER INPUT IT GETS.}\\
The DFA is on the next page, below this will be a quick explanation of the DFA.\\
when we begin processing input we can have 3 possible transitions. we can move to final state from 101 since 1 + 0 = 1 with no carry over, we can move to final state from 011 since 0 + 1 = 1 with no carry over, and we can move to a state which checks if the carry over was from a previous result. Since input is taken left to right and binary is read from right to left, we have to proccess the carry over first. if we have 001 (indicating 0 + 0 = 1) we will check if our next input has 110 (1 + 1 = 0 carry 1). from all these final states we can then add links to each other and loop 000 on all except the carry over state. we can also add loops to states that have 101 and 011 since they will always be true and have no carry over.
Some example runthroughs with simple accepted and non-accepted words.
\begin{enumerate}[1.]
    \item accepted word =
    $\bigl(\begin{smallmatrix}0\\0\\1\\ \end{smallmatrix}\bigr)$
    $\bigl(\begin{smallmatrix}1\\1\\0\\ \end{smallmatrix}\bigr)$
    $\bigl(\begin{smallmatrix}0\\0\\0\\ \end{smallmatrix}\bigr)$
    $\bigl(\begin{smallmatrix}1\\0\\1\\ \end{smallmatrix}\bigr)$.\\
    from our DFA we begin at q0 and transition to q1 from 001, next we transition to q2 from 110. we stay at q2 from self loop from 000, and transition to final state q4 from 101. since we finish at a final state this sequence of input is accepted and to further prove it is:\\
    $bin$($t$(w)) = 1001 = 9, 
    $bin$($f$(w)) = 0101 = 5 and
    $bin$($s$(w)) = 0100 = 4.\\
    as can be seen $bin$($t$(w)) = $bin$($f$(w)) + $bin$($s$(w)) since 9 = 5+ 4.\\
    \item rejected word =     $\bigl(\begin{smallmatrix}0\\0\\1\\ \end{smallmatrix}\bigr)$
    $\bigl(\begin{smallmatrix}1\\1\\1\\ \end{smallmatrix}\bigr)$
    $\bigl(\begin{smallmatrix}0\\0\\0\\ \end{smallmatrix}\bigr)$
    $\bigl(\begin{smallmatrix}1\\0\\1\\ \end{smallmatrix}\bigr)$.\\
    from our DFA we begin at q0 and transition to q1 from 001, next we transition to our error state where all inputs loop to the same state which is not a final state. since we finish at the error state this input is rejected. To further prove this is: \\
    $bin$($t$(w)) = 1101 = 13, 
    $bin$($f$(w)) = 0101 = 5 and
    $bin$($s$(w)) = 0100 = 4.
    as can be seen this is not true and rejected since 13 != 5 + 4 and our property does not hold.\\
\end{enumerate}

\begin{tikzpicture}[shorten >=1pt,node distance=7cm,on grid,auto] 
   \node[state,initial, accepting] (q_0)   {$q_0$}; 
   \node[state] [below=of q_0] (q_1) {$q_1$};
  \node[state,accepting] [below right=of q_1] (q_2) {$q_2$};
   \node[state,accepting] [above right=of q_0] (q_3) {$q_3$};
      \node[state,accepting] [right=of q_0] (q_4) {$q_4$};
    \path[->] 
    (q_0) edge  [loop above] node {000}(q_0)
          edge [swap] node {001} (q_1)
          edge [swap above] node {011} (q_3)
          edge [swap above] node {101} (q_4)
    (q_1) edge [bend left] node {110}(q_2)
    (q_2) edge [bend left] node {001} (q_1)
          edge [bend right = 20] node {101} (q_4)
          edge [bend right = 90] node {011} (q_3)
          edge [loop below] node {000} (q_2)
    (q_3) edge [bend left] node {101} (q_4)
          edge [bend left, above] node {001} (q_1)
          edge [loop above] node {011} (q_3)
          edge [loop left] node {000} (q_3)
    (q_4) edge [bend left] node {011} (q_3)
          edge [bend left] node {001} (q_1)
          edge [loop below] node {000} (q_4)
          edge [loop right] node {101} (q_4);
    
\end{tikzpicture}

\newpage
\section{Problem 5}
Let $\L \subseteq \Sigma^*$ be a language over $\Sigma$. Recall the definition of $\equiv_L \subseteq \Sigma^* \times \Sigma^*:$
\begin{center}
    $w \equiv_L v$  iff  $\forall z \in \Sigma^* : wz \in \L \Leftrightarrow vz \in \L$
\end{center}
\begin{enumerate}[(a)]
    \item Show that $\equiv_L$ is an equivalence relation. \moveToRight{6 marks}\\\\Solution:\\
    To prove that $\equiv_L$ is an equivalence relation we need to show that:
    
    \begin{enumerate} [1.]
        \item $\equiv_L$ is symmetric\\
        To show $\equiv_L$ is symmetric, we have to show:\\
        a $\equiv_L$ b $\iff$ b $\equiv_L$ a, where a, b $\in \Sigma^*$.
        \\
        This is true from the definition of $\equiv_L$ since it is a bi-directional implication,\\ (iff  $\forall z \in \Sigma^* : az \in \L \Leftrightarrow bz \in \L$), $\equiv_L$ is symmetric.
        
        \item $\equiv_L$ is reflexive\\
        To show $\equiv_L$ is reflexive, we have to show:\\
        a $\equiv_L$ a where a $\in$ $\Sigma^*$.\\
        since $\forall z \in \Sigma^* : az \in L \Leftrightarrow az \in L$, as a = a, then $\equiv_L$ is also reflexive.
        
        \item $\equiv_l$ is transitive\\
        To show $\equiv_L$ is transitive, we have to show:\\
        ((a $\equiv_L$ b) $\land$ (b $\equiv_L$ c)) $\to$ (a $\equiv_L$ c) where a, b, c $\in \Sigma^*$.\\
        $\forall z \in \Sigma^* : az \in L \Leftrightarrow bz \in L.$ Since $bz \in L $ then $cz \in L (b \equiv_L c)$. This means that:\\ $\forall z \in \Sigma^* : az \in L \Leftrightarrow bz \in L \Leftrightarrow cz \in L$. Essentially what we are saying is that if az is in the language, then bz is in the language, this in turn means cz is in the language due to (a $\equiv_L$ b) and (b $\equiv_L$ c). This means that a $\equiv_L$ c, thus $\equiv_L$ is transitive
    \end{enumerate}
    Since $\equiv_L$ is symmetric, reflexive and transitive, then $\equiv_L$ is an equivalence relation.
    \item if $\L$ is regular, show that for any word w, [w] (the equivalence class of w under $\equiv_L$) is also regular. \moveToRight{4 marks}\\\\
    Solution:\\
    to show that for any word w, [w] is regular under $\equiv_L$, we need to show that the equivalence class of [w] is finite. This will then allow us to use the Myhill-Nerode theorem to prove [w] is regular. given that L is regular there are a finite amount of [w] from Myhill-Nerode theorem. Since the equivalence class [w] can be seen as a subset of our language $\L$ which is finite (since it is regular); then [w] must also be finite since it is a subset of $\L$. Since [w] is finite then [w] is also regular.

    
\end{enumerate}
\end{document}
